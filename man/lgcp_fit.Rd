% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analysis_functions.R
\name{lgcp_fit}
\alias{lgcp_fit}
\title{Fit an approximate log-Gaussian Cox Process model}
\usage{
lgcp_fit(
  grid_data,
  popdens,
  covs = NULL,
  m = 10,
  L = 1.5,
  dir = NULL,
  iter_warmup = 500,
  iter_sampling = 500,
  chains = 3,
  parallel_chains = 3,
  priors = NULL,
  verbose = TRUE,
  use_cmdstanr = FALSE,
  ...
)
}
\arguments{
\item{grid_data}{sf object. A regular grid covering the area of interest (see
\link[rts2]{create_grid}). Columns must include \verb{t*}, giving the case
count in each time period, as well as any covariates to include in the model
(see \link[rts2]{add_covariates}) and the population density}

\item{popdens}{character string. Name of the population density column}

\item{covs}{vector of character string. Base names of the covariates to
include. For temporally-varying covariates only the stem is required and not
the individual column names for each time period (e.g. \code{dayMon} and not \code{dayMon1},
\code{dayMon2}, etc.)}

\item{m}{integer. Number of basis functions. See Details.}

\item{L}{integer. Boundary condition as proportionate extension of area, e.g.
\code{L=2} is a doubling of the analysis area. See Details.}

\item{dir}{character string. Directory to save ouptut.}

\item{iter_warmup}{integer. Number of warmup iterations}

\item{iter_sampling}{integer. Number of sampling iterations}

\item{chains}{integer. Number of chains}

\item{parallel_chains}{integer. Number of parallel chains}

\item{priors}{list. See Details}

\item{verbose}{logical. Provide feedback on progress}

\item{use_cmdstanr}{logical. Defaults to false. If true then cmdstanr will be used
instead of rstan.}

\item{...}{additional options to pass to `$sample()``, see \link[cmdstanr]{sample}}
}
\value{
A \link[rstan]{stanfit} or a \link[cmdstanr]{CmdStanMCMC} object
}
\description{
Fit an approximate log-Gaussian Cox Process model
}
\details{
Our statistical model is a Log Gaussian cox process,
whose realisation is observed on the Cartesian area of interest
A and time period T. The resulting data are relaisations of an inhomogeneous
Poisson process with stochastic intensity function \eqn{\{\lambda{s,t}:s\in A, t \in T\}}.
We specify a log-linear model for the intensity:

\deqn{\lambda(s,t) = r(s,t)exp(X(s,t)'\gamma + Z(s,t))}

where r(s,t) is a spatially or spatio-temporally varying Poisson offset.
X(s,t) is a length Q vector of covariates including an intercept and
Z(s,t) is a latent field. We use an auto-regressive specification for the
latent field, with spatial innovation in each field specified as a spatial
Gaussian process.

We use the fast and accurate approximation for fully Bayesian Gaussian
Processes proposed by Solin and Särkkä (1), using basis function
approximations based on approximation
via Laplace eigenfunctions for stationary covariance functions.
See references (1) and (2) for complete details. The approximation is a linear sum
of \code{m} eigenfunctions with the boundary conditions in each dimension \verb{[-L,L]}.
Coordinates in each dimension are scaled to \verb{[-1,1]}, so L represents the
proportionate extension of the analysis area.

\emph{Priors}
The priors should be provided as a list:\preformatted{priors <- list(
  prior_lscale=c(0,0.5),
  prior_var=c(0,0.5),
  prior_linpred_mean=c(-5,rep(0,7)),
  prior_linpred_sd=c(3,rep(1,7))
)
}

where these refer to the priors:
\code{prior_lscale}: the length scale parameter has a half-normal prior \eqn{N(a,b^2)I[0,\infty)}. The vector is \code{c(a,b)}.
\code{prior_var}: the standard deviation term has a half normal prior \eqn{\sigma ~ N(a,b^2)I[0,\infty)}. The vector is \code{c(a,b)}.
\code{prior_linpred_mean} and \code{prior_linpred_sd}: The parameters of the linear predictor.
If X is the nT x Q matrix of covariates, with the first column as ones for the intercept,
then the linear prediction contains the term \eqn{X'\gamma}. Each parameter in \eqn{\gamma} has prior
\eqn{\gamma_q ~ N(a_q,b_q^2)}.
\code{prior_linpred_mean} should be the vector \verb{(a_1,a_2,...,a_Q)} and
\code{prior_linpred_sd} should be \verb{(b_1,b_2,...,b_Q)}.
}
\examples{
\dontrun{
b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- create_grid(b1,0.5)
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20))
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
cov1 <- create_grid(b1,0.8)
cov1$cov <- runif(nrow(cov1))
g1 <- add_covariates(g1,
                     cov1,
                     zcols="cov",
                    verbose = FALSE)
g1 <- points_to_grid(g1, dp, laglength=5)
priors <- list(
  prior_lscale=c(0,0.5),
  prior_var=c(0,0.5),
  prior_linpred_mean=c(0),
  prior_linpred_sd=c(5)
  )
res <- lgcp_fit(g1,
                popdens="cov")
}
}
\references{
(1) Solin A, Särkkä S. Hilbert space methods for reduced-rank Gaussian
process regression. Stat Comput. 2020;30:419–46.
doi:10.1007/s11222-019-09886-w.

(2) Riutort-Mayol G, Bürkner P-C, Andersen MR, Solin A, Vehtari A.
Practical Hilbert space approximate Bayesian Gaussian processes for
probabilistic programming. 2020. http://arxiv.org/abs/2004.11408.
}
