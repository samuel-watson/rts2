# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Generate the matrices A and D for the nearest neighbour approximation
#' 
#' @details
#' The neatest neighbour Gaussian process approximation to the inverse covariance matrix
#' is \eqn{(I-A)D^-1(I-A)^T}. This function generates matrix D and a "collapsed" version of matrix A.
#' If there are `m` nearest neighbours then A will have `m` rows and columns equal to the number of observations, `n`.
#' The "full" A matrix is n x n. See \link[rts2]{full_A} for converting A to full representation.
#' @param cov An integer matrix with columns of block identifier, dimension of block, function definition, number of variables
#' in the argument to the funciton, and index of the parameters, respectively. Rows are specific functions of each block.
#' @param data Vector of data. Created by flattening the matrices in column-major order of the data used in each block.
#' @param NN A matrix of integers with rows equal to the number of nearest neighbours and columns equal to the number of observations.
#' Each element is the set of nearest neighbours. See \link[rts2]{genNN}.
#' @param gamma Vector of parameters used to generate the matrix D. 
#' @return A named list containing matrices A and D.
get_AD <- function(cov, data, NN, theta) {
    .Call(`_rts2_get_AD`, cov, data, NN, theta)
}

#' Coverts a collapsed matrix A to full matrix A
#' 
#' The output of the function \link{rts2}[get_AD] is a m x n matrix A, where 
#' m is the number of nearest neighbours. This function coverts A into a full 
#' n x n matrix.
#' @param A A "collapsed" matrix A output from \link[rts2]{get_AD}
#' @param NN A matrix of integers with rows equal to the number of nearest neighbours and columns equal to the number of observations.
#' Each element is the set of nearest neighbours. See \link[rts2]{genNN}.
#' @return A matrix
full_A <- function(A, NN) {
    .Call(`_rts2_full_A`, A, NN)
}

#' Generates an approximate Cholesky decomposition of the covariance matrix
#' 
#' Takes the output from the function \link[rts2]{get_AD} and generates the approximate
#' Cholesky decomposition of the covariance matrix of the random effects.
#' 
#' @details
#' For the nearest neighbour Gaussian process approximation, the covariance matrix of the random effects/
#' latent fieldis approximated by \eqn{\Sigma = (I-A)^{-T}D(I-A)^{-1}} where matrices 
#' A and D are determined by the set of nearest neighbours in `NN` (see \link[rts2]{genNN}). 
#' The matrices A and D are returned by the function \link[rts2]{get_AD}.
#' Many of the calculations for the maximum likelihood model fitting methods 
#' require the Cholesky decomposition of the covariance matrix \eqn{\Sigma = LL^T}, which is approximated here 
#' by \eqn{(I-A)^{-T}D^{1/2}}. This function generates this lower triangular matrix
#' using a forward substitution algorithm as A is strictly lower triangular and D is diagonal.
#' @param A A "collapsed" matrix A output from \link[rts2]{get_AD}
#' @param D A diagonal matrix for the approximate LDL decomposition from \link[rts2]{get_AD}. 
#' @param NN A matrix of integers with rows equal to the number of nearest neighbours and columns equal to the number of observations.
#' Each element is the set of nearest neighbours. See \link[rts2]{genNN}.
#' @return A lower triangular matrix  
inv_ldlt <- function(A, D, NN) {
    .Call(`_rts2_inv_ldlt`, A, D, NN)
}

#' Generates the matrix ZL
#' 
#' For the MCMCML algorithms the matrix ZL multiplies the random effects u~N(0,I) to produce
#' the latent field.
#' 
#' @details
#' The LGCP model specified in this package uses an auto-regressive specification for the random effect 
#' terms. If S(t) are the random effects for time period t, then these are specified as S(t) = rho*S(t-1) + v(t)
#' where v(t) is a spatial innovation term specified as a spatial Gaussian process. The Cholesky decomposition 
#' of the covariance of v(t) is L and is the same in each time period, such that Lu = v where u~N(0,I). The matrix
#' Z generates the weighted sums of v(t) such that S = ZLu. This function produces ZL.
#' @param L Lower triangular matrix representing the Cholesky decomposition of the spatial terms in one time period.
#' @param nT Integer specifying the number of time periods
#' @param rho Scalar, the auto-regressive parameter value.
#' @return A matrix ZL
get_ZL <- function(L, nT, rho) {
    .Call(`_rts2_get_ZL`, L, nT, rho)
}

#' Generates the random effect terms from independent samples
#' 
#' For the MCMCML algorithms the spatial innovation terms are v. The Cholesky decomposition of the covariance matrix
#' of v is L. Random effects are sampled as standard normals u~N(0,I). This function generates v from samples u.
#' 
#' @details
#' The LGCP model specified in this package uses an auto-regressive specification for the random effect 
#' terms. If S(t) are the random effects for time period t, then these are specified as S(t) = rho*S(t-1) + v(t)
#' where v(t) is a spatial innovation term specified as a spatial Gaussian process. The Cholesky decomposition 
#' of the covariance of v(t) is L and is the same in each time period, such that Lu = v where u~N(0,I). This function 
#' produces v from L and u. The MCMCML algorithms also generate multiple samples of u so multiple samples of v are returned.
#' @param L Lower triangular matrix representing the Cholesky decomposition of the spatial terms in one time period.
#' @param u A matrix of samples of u
#' @return A matrix Lu.
get_Lu <- function(L, u) {
    .Call(`_rts2_get_Lu`, L, u)
}

#' Generates samples of the latent field from samples of u
#' 
#' For the MCMCML algorithms the matrice Z and L multiply the random effects u~N(0,I) to produce
#' the latent field.
#' 
#' @details
#' The LGCP model specified in this package uses an auto-regressive specification for the random effect 
#' terms. If S(t) are the random effects for time period t, then these are specified as S(t) = rho*S(t-1) + v(t)
#' where v(t) is a spatial innovation term specified as a spatial Gaussian process. The Cholesky decomposition 
#' of the covariance of v(t) is L and is the same in each time period, such that Lu = v where u~N(0,I). The matrix
#' Z generates the weighted sums of v(t) such that S = ZLu. This function produces S given Z, L, and u.
#' @param L Lower triangular matrix representing the Cholesky decomposition of the spatial terms in one time period.
#' @param u A matrix of samples of u
#' @param nT Integer specifying the number of time periods
#' @param rho Scalar, the auto-regressive parameter value.
#' @return A matrix ZL
get_ZLu <- function(L, u, nT, rho) {
    .Call(`_rts2_get_ZLu`, L, u, nT, rho)
}

#' Generates predictions of the intensity of each region for the region model
#' 
#' The "region model" specifies the intensity for each region as a combination of the
#' offset, linear predictor, and a weighted combination of the intensity of overlapping 
#' computational grid cells. This function returns the region intensities given above 
#' components.
#' @param xb A vector of values of the linear predictor X*beta
#' @param y Vector of outcome counts 
#' @param zu Matrix with samples of the random field, see \link[rts2]{get_ZLu}.
#' @param offset Vector of offset values
#' @param nT Integer. Number of time periods.
#' @param n_cell Vector of integers specifying the number of grid cells intersecting each region, 
#' see the `region_data()` function in the \link[rts2]{grid} class.
#' @param cell_id Vector of indices of grid cells overlapping each region, in order,
#' see the `region_data()` function in the \link[rts2]{grid} class.
#' @param q_weights Vector specifying the proportion of the area of each region covered by overlapping 
#' grid cells, see the `region_data()` function in the \link[rts2]{grid} class.
#' @return A matrix with samples of the intensity in each region at each time point.
region_intensity <- function(xb, y, zu, offset, nT, n_cell, cell_id, q_weights) {
    .Call(`_rts2_region_intensity`, xb, y, zu, offset, nT, n_cell, cell_id, q_weights)
}

#' Maximum likelihood optimisation step for MCMCML algorithm for full LGCP model
#' 
#' Maximum likelihood optimisation step for linear predictor parameters and covariance 
#' parameters for MCMCML algorithm. The model is a point data full LGCP. This function is 
#' used internally, use `lgcp_fit_ml()` function in the \link[rts2]{grid} class.
#' @param cov An integer matrix with columns of block identifier, dimension of block, function definition, number of variables
#' in the argument to the funciton, and index of the parameters, respectively. Rows are specific functions of each block.
#' @param data Vector of data. Created by flattening the matrices in column-major order of the data used in each block.
#' @param X Matrix of covariates for the linear predictor
#' @param y Vector of outcome counts for the computational grid cells
#' @param u Matrix of samples of the random effects terms with rows equal to the number of grid cells times by number of time 
#' periods, and columns equal to the number of samples.
#' @param nT Integer specifying the number of time periods
#' @param start Vector of starting values for the model parameters in order beta, theta (covariance parameters), rho
#' @param offset Vector of offset values
#' @param trace Either 0, 1, or 2 indicating the level of detail to print to the console
#' @param mcnr Logical indicating whether to use newton-raphson (`TRUE`) or expectation maximisation (`FALSE`) for the estimation 
#' of the parameters of the linear predictor
#' @param known_cov Logical indicating whether to treat the covariance parameters as known.
#' @return A named list with beta, theta, and rho parameters
lgcp_optim <- function(cov, data, X, y, u, nT, start, offset, trace, mcnr = TRUE, known_cov = FALSE) {
    .Call(`_rts2_lgcp_optim`, cov, data, X, y, u, nT, start, offset, trace, mcnr, known_cov)
}

#' Maximum likelihood model fitting using Laplace approximation to likelihood for full LGCP
#' 
#' Model fitting of the full Log Gaussian Cox Process model using a Laplace approximation to the likelihood.
#' This function is called internally, see the `fit_lgcp_la` in the \link[rts2]{grid} class.
#' @param cov An integer matrix with columns of block identifier, dimension of block, function definition, number of variables
#' in the argument to the funciton, and index of the parameters, respectively. Rows are specific functions of each block.
#' @param data Vector of data. Created by flattening the matrices in column-major order of the data used in each block.
#' @param X Matrix of covariates for the linear predictor
#' @param y Vector of outcome counts for the computational grid cells
#' @param start Vector of starting values for the model parameters in order beta, theta (covariance parameters), rho
#' @param offset Vector of offset values
#' @param nT Integer specifying the number of time periods
#' @param known_cov Logical indicating whether to treat the covariance parameters as known.
#' @param usehess Logical indicating whether to use the Hessian matrix to estimate standard errors
#' @param tol Maximum difference between parameter values between iterations at which the algorithm is considered to have converged
#' @param verbose Logical indicating whether to provide output to the console
#' @param trace Either 0, 1, or 2 indicating the level of detail to print to the console
#' @param maxiter Integer. Maximum number of iterations of the algorithm.
#' @return A named list with beta, theta, and rho parameters with standard errors and random effect estimates
lgcp_optim_la <- function(cov, data, X, y, start, offset, nT, known_cov = FALSE, usehess = FALSE, tol = 1e-3, verbose = TRUE, trace = 0L, maxiter = 20L) {
    .Call(`_rts2_lgcp_optim_la`, cov, data, X, y, start, offset, nT, known_cov, usehess, tol, verbose, trace, maxiter)
}

#' Maximum likelihood optimisation step for MCMCML algorithm for the region LGCP model
#' 
#' Maximum likelihood optimisation step for linear predictor parameters and covariance 
#' parameters for MCMCML algorithm. The model is region data LGCP model. This function is 
#' used internally, use `lgcp_fit_ml()` function in the \link[rts2]{grid} class.
#' @param cov An integer matrix with columns of block identifier, dimension of block, function definition, number of variables
#' in the argument to the funciton, and index of the parameters, respectively. Rows are specific functions of each block.
#' @param data Vector of data. Created by flattening the matrices in column-major order of the data used in each block.
#' @param X Matrix of covariates for the linear predictor
#' @param y Vector of outcome counts for the computational grid cells
#' @param u Matrix of samples of the random effects terms with rows equal to the number of grid cells times by number of time 
#' periods, and columns equal to the number of samples.
#' @param nT Integer specifying the number of time periods
#' @param start Vector of starting values for the model parameters in order beta, theta (covariance parameters), rho
#' @param offset Vector of offset values
#' @param n_cell Vector of integers specifying the number of grid cells intersecting each region, 
#' see the `region_data()` function in the \link[rts2]{grid} class.
#' @param cell_id Vector of indices of grid cells overlapping each region, in order,
#' see the `region_data()` function in the \link[rts2]{grid} class.
#' @param q_weights Vector specifying the proportion of the area of each region covered by overlapping 
#' grid cells, see the `region_data()` function in the \link[rts2]{grid} class.
#' @param trace Either 0, 1, or 2 indicating the level of detail to print to the console
#' @param mcnr Logical indicating whether to use newton-raphson (`TRUE`) or expectation maximisation (`FALSE`) for the estimation 
#' of the parameters of the linear predictor
#' @param known_cov Logical indicating whether to treat the covariance parameters as known.
#' @return A named list with beta, theta, and rho parameters
lgcp_region_optim <- function(cov, data, X, y, u, nT, start, offset, n_cell, cell_id, q_weights, trace, mcnr = TRUE, known_cov = FALSE) {
    .Call(`_rts2_lgcp_region_optim`, cov, data, X, y, u, nT, start, offset, n_cell, cell_id, q_weights, trace, mcnr, known_cov)
}

#' Generate matrix of nearest neighbours
#' 
#' Generates a M by n matrix of nearest neighbours. For observations with index less than M,
#' only i-1 nearest neighbours are generated.
#' 
#' @param x Matrix with x and y coordinates of the observations
#' @param M Number of nearest neighbours
#' @return A M by n matrix of nearest neighbours. Note the indexing of the observations returned
#' by this function starts at zero.
genNN <- function(x, M) {
    .Call(`_rts2_genNN`, x, M)
}

#' Maximum likelihood optimisation step for MCMCML algorithm using nearest neighbour approximation
#' 
#' Maximum likelihood optimisation step for linear predictor parameters and covariance 
#' parameters for MCMCML algorithm. The model is a point data LGCP using the nearest neighbour 
#' Gaussian process approximation. This function is  used internally, 
#' use `lgcp_fit_ml()` function in the \link[rts2]{grid} class.
#' @param cov An integer matrix with columns of block identifier, dimension of block, function definition, number of variables
#' in the argument to the funciton, and index of the parameters, respectively. Rows are specific functions of each block.
#' @param data Vector of data. Created by flattening the matrices in column-major order of the data used in each block.
#' @param X Matrix of covariates for the linear predictor
#' @param y Vector of outcome counts for the computational grid cells
#' @param NN A matrix of integers with rows equal to the number of nearest neighbours and columns equal to the number of observations.
#' Each element is the set of nearest neighbours. See \link[rts2]{genNN}.
#' @param u Matrix of samples of the random effects terms with rows equal to the number of grid cells times by number of time 
#' periods, and columns equal to the number of samples.
#' @param nT Integer specifying the number of time periods
#' @param start Vector of starting values for the model parameters in order beta, theta (covariance parameters), rho
#' @param offset Vector of offset values
#' @param trace Either 0, 1, or 2 indicating the level of detail to print to the console
#' @param mcnr Logical indicating whether to use newton-raphson (`TRUE`) or expectation maximisation (`FALSE`) for the estimation 
#' of the parameters of the linear predictor
#' @param known_cov Logical indicating whether to treat the covariance parameters as known.
#' @return A named list with beta, theta, and rho parameters
nngp_optim <- function(cov, data, X, y, NN, u, nT, start, offset, trace, mcnr = TRUE, known_cov = FALSE) {
    .Call(`_rts2_nngp_optim`, cov, data, X, y, NN, u, nT, start, offset, trace, mcnr, known_cov)
}

#' Maximum likelihood model fitting using Laplace approximation to likelihood and nearest neighbour Gaussian process approximation
#' 
#' Model fitting of the full Log Gaussian Cox Process model using a Laplace approximation to the likelihood.
#' This function is called internally, see the `fit_lgcp_la` in the \link[rts2]{grid} class.
#' @param cov An integer matrix with columns of block identifier, dimension of block, function definition, number of variables
#' in the argument to the funciton, and index of the parameters, respectively. Rows are specific functions of each block.
#' @param data Vector of data. Created by flattening the matrices in column-major order of the data used in each block.
#' @param X Matrix of covariates for the linear predictor
#' @param y Vector of outcome counts for the computational grid cells
#' @param NN A matrix of integers with rows equal to the number of nearest neighbours and columns equal to the number of observations.
#' Each element is the set of nearest neighbours. See \link[rts2]{genNN}.
#' @param start Vector of starting values for the model parameters in order beta, theta (covariance parameters), rho
#' @param offset Vector of offset values
#' @param nT Integer specifying the number of time periods
#' @param known_cov Logical indicating whether to treat the covariance parameters as known.
#' @param usehess Logical indicating whether to use the Hessian matrix to estimate standard errors
#' @param tol Maximum difference between parameter values between iterations at which the algorithm is considered to have converged
#' @param verbose Logical indicating whether to provide output to the console
#' @param trace Either 0, 1, or 2 indicating the level of detail to print to the console
#' @param maxiter Integer. Maximum number of iterations of the algorithm.
#' @return A named list with beta, theta, and rho parameters with standard errors and random effect estimates
nngp_optim_la <- function(cov, data, X, y, NN, start, offset, nT, known_cov = FALSE, usehess = FALSE, tol = 1e-3, verbose = TRUE, trace = 0L, maxiter = 10L) {
    .Call(`_rts2_nngp_optim_la`, cov, data, X, y, NN, start, offset, nT, known_cov, usehess, tol, verbose, trace, maxiter)
}

#' Maximum likelihood optimisation step for MCMCML algorithm for the region LGCP model with nearest neighbour approximation
#' 
#' Maximum likelihood optimisation step for linear predictor parameters and covariance 
#' parameters for MCMCML algorithm. The model is region data LGCP model with a nearest neighbour Gaussian 
#' process approximation. This function is used internally, use `lgcp_fit_ml()` function in the \link[rts2]{grid} class.
#' @param cov An integer matrix with columns of block identifier, dimension of block, function definition, number of variables
#' in the argument to the funciton, and index of the parameters, respectively. Rows are specific functions of each block.
#' @param data Vector of data. Created by flattening the matrices in column-major order of the data used in each block.
#' @param X Matrix of covariates for the linear predictor
#' @param y Vector of outcome counts for the computational grid cells
#' @param NN A matrix of integers with rows equal to the number of nearest neighbours and columns equal to the number of observations.
#' Each element is the set of nearest neighbours. See \link[rts2]{genNN}.
#' @param u Matrix of samples of the random effects terms with rows equal to the number of grid cells times by number of time 
#' periods, and columns equal to the number of samples.
#' @param nT Integer specifying the number of time periods
#' @param start Vector of starting values for the model parameters in order beta, theta (covariance parameters), rho
#' @param offset Vector of offset values
#' @param n_cell Vector of integers specifying the number of grid cells intersecting each region, 
#' see the `region_data()` function in the \link[rts2]{grid} class.
#' @param cell_id Vector of indices of grid cells overlapping each region, in order,
#' see the `region_data()` function in the \link[rts2]{grid} class.
#' @param q_weights Vector specifying the proportion of the area of each region covered by overlapping 
#' grid cells, see the `region_data()` function in the \link[rts2]{grid} class.
#' @param trace Either 0, 1, or 2 indicating the level of detail to print to the console
#' @param mcnr Logical indicating whether to use newton-raphson (`TRUE`) or expectation maximisation (`FALSE`) for the estimation 
#' of the parameters of the linear predictor
#' @param known_cov Logical indicating whether to treat the covariance parameters as known.
#' @return A named list with beta, theta, and rho parameters
nngp_region_optim <- function(cov, data, X, y, NN, u, nT, start, offset, n_cell, cell_id, q_weights, trace, mcnr = TRUE, known_cov = FALSE) {
    .Call(`_rts2_nngp_region_optim`, cov, data, X, y, NN, u, nT, start, offset, n_cell, cell_id, q_weights, trace, mcnr, known_cov)
}

