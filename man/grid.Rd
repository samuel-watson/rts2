% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/griddata_class.R
\name{grid}
\alias{grid}
\title{An rts grid object}
\description{
An rts grid object

An rts grid object
}
\details{
An rts grid object is an R6 class holding the spatial data with data, model fitting, and analysis functions.

\strong{INTRODUCTION}

The various methods of the class include examples and details of their implementation. The \pkg{sf} package is used for
all spatial data. A typical workflow with this class would
be:
\enumerate{
\item Create a new grid object. The class is initialized with either a single polygon describing the area of interest or a collection
of polygons if spatially aggregated data are used.
\item If the location (and times) of cases are available (i.e. the data are not spatially aggregated), then we map the points to the computational
grid. The function \link[rts2]{create_points} can generate point data in the correct \pkg{sf} format. The member function \code{points_to_grid} will then
map these data to the grid. Counts can also be manually added to grid data. For region data, since the counts are assumed to be already aggregated, these
must be manually provided by the user. The case counts must appear in columns with specific names. If there is only a single time period then the counts
must be in a column named \code{y}. If there are multiple time periods then the counts must be in columns names \code{t1}, \code{t2}, \code{t3},... Associated columns labelled
\code{date1}, \code{date2}, etc. will permit use of some functionality regarding specific time intervals.
\item If any covariates are to be used for the modelling, then these can be mapped to the compuational grid using the function \code{add_covariates()}. Other
functions, \code{add_time_indicators()} and \code{get_dow()} will also generate relevant temporal indicators where required. At a minimum we would recommend including
a measure of population density.
\item Fit a model. There are multiple methods for model fitting, which are available through the member functions \code{lgcp_ml()} and \code{lgcp_bayes()} for maximum likelihood
and Bayesian approaches, respectively. The results are stored internally and optionally returned as a \code{rtsFit} object.
\item Summarise the output. The main functions for summarising the output are \code{extract_preds()}, which will generate predictions of relative risk, incidence rate
ratios, and predicted incidence, and \code{hotspots()}, which will estimate probabilities that these statistics exceed given thresholds. For spatially-aggregated data models,
the relative risk applies to the grid, whereas rate ratios and predicted incidence applies to the areas.
\item Predictions can be visualised or aggregated to relevant geographies with the \code{plot()} and \code{aggregate()} functions.
}
Specific details of the implementation of each of these functions along with examples appear below.

\strong{PLOTTING}

If \code{zcol} is not specified then only the geometry is plotted, otherwise the covariates specified will be plotted.
The user can also use sf plotting functions on self$grid_data and self$region_data directly.

\strong{POINTS TO GRID}

Given the sf object with the point locations and date output from
\code{create_points()}, the functions will add columns to \code{grid_data} indicating
the case count in each cell in each time period.

Case counts are generated for each grid cell for each time period. The user
can specify the length of each time period; currently \code{day}, \code{week}, and \code{month}
are supported.

The user must also specify the number of time periods to include with the
\code{laglength} argument. The total number of time periods is the specified lag
length counting back from the most recent case. The columns in the output
will be named \code{t1}, \code{t2},... up to the lag length, where the highest number
is the most recent period.

\strong{ADDING COVARIATES}

\emph{Spatially-varying data only}

\code{cov_data} is an object describing covariate over the area of interest.
sf, RasterLayer and SpatRaster objects are supported, with rasters converted internally to sf.
The values are mapped onto \code{grid_data}. For each grid cell in \code{grid_data} a weighted
average of each covariate listed in \code{zcols} is generated with weights either
equal to the area of intersection of the grid cell and the polygons in
\code{cov_data} (\code{weight_type="area"}), or this area multiplied by the population
density of the polygon for population weighted (\code{weight_type="pop"}). Columns
with the names in \code{zcols} are added to the output.

\emph{Temporally-varying only data}

\code{cov_data} is a data frame with number of rows
equal to the number of time periods. One of the columns must be called \code{t} and
have values from 1 to the number of time periods. The other columns of the data
frame have the values of the covariates for each time period. See
\code{get_dow()} for day of week data. A total of
length(zcols)*(number of time periods) columns are added to the output: for each
covariate there will be columns appended with each time period number. For example,
\code{dayMon1}, \code{dayMon2}, etc.

\emph{Spatially and temporally varying data}

There are two ways to add data that
vary both spatially and temporally. The final output for use in analysis must
have a column for each covariate and each time period with the same name appended
by the time period number, e.g. \code{covariateA1},\code{covariateA2},... If the covariate
values for different time periods are in separate sf objects, one can follow
the method for spatially-varying only data above and append the time period number
using the argument \code{t_label}. If the values for different time periods are in the same
sf object then they should be named as described above and then can be added
as for spatially-varying covariates, e.g. \code{zcols=c("covariateA1","covariateA2")}.

\strong{BAYESIAN MODEL FITTING}

The grid data must contain columns \verb{t*}, giving the case
count in each time period (see \code{points_to_grid}), as well as any covariates to include in the model
(see \code{add_covariates}) and the population density. Otherwise, if the data are regional data, then the outcome
counts must be in self$region_data

Our statistical model is a Log Gaussian cox process,
whose realisation is observed on the Cartesian area of interest
A and time period T. The resulting data are relaisations of an inhomogeneous
Poisson process with stochastic intensity function \eqn{\{\lambda{s,t}:s\in A, t \in T\}}.
We specify a log-linear model for the intensity:

\deqn{\lambda(s,t) = r(s,t)exp(X(s,t)'\gamma + Z(s,t))}

where r(s,t) is a spatio-temporally varying Poisson offset.
X(s,t) is a length Q vector of covariates including an intercept and
Z(s,t) is a latent field. We use an auto-regressive specification for the
latent field, with spatial innovation in each field specified as a spatial
Gaussian process.

The argument \code{approx} specifies whether to use a full LGCP model (\code{approx='none'}) or whether
to use either a nearest neighbour approximation (\code{approx='nngp'}) or a "Hilbert space" approximation
(\code{approx='hsgp'}). For full details of NNGPs see XX and for Hilbert space approximations see references (1) and (2).

\emph{Priors}

For Bayesian model fitting, the priors should be provided as a list to the griddata object:

\if{html}{\out{<div class="sourceCode">}}\preformatted{griddata$priors <- list(
  prior_lscale=c(0,0.5),
  prior_var=c(0,0.5),
  prior_linpred_mean=c(-5,rep(0,7)),
  prior_linpred_sd=c(3,rep(1,7))
)
}\if{html}{\out{</div>}}

where these refer to the priors:
\code{prior_lscale}: the length scale parameter has a half-normal prior \eqn{N(a,b^2)I[0,\infty)}. The vector is \code{c(a,b)}.
\code{prior_var}: the standard deviation term has a half normal prior \eqn{\sigma ~ N(a,b^2)I[0,\infty)}. The vector is \code{c(a,b)}.
\code{prior_linpred_mean} and \code{prior_linpred_sd}: The parameters of the linear predictor.
If X is the nT x Q matrix of covariates, with the first column as ones for the intercept,
then the linear prediction contains the term \eqn{X'\gamma}. Each parameter in \eqn{\gamma} has prior
\eqn{\gamma_q ~ N(a_q,b_q^2)}.
\code{prior_linpred_mean} should be the vector \verb{(a_1,a_2,...,a_Q)} and
\code{prior_linpred_sd} should be \verb{(b_1,b_2,...,b_Q)}.

\strong{MAXIMUM LIKELIHOOD MODEL FITTING}

The grid data must contain columns \verb{t*}, giving the case
count in each time period (see \code{points_to_grid}), as well as any covariates to include in the model
(see \code{add_covariates}) and the population density. Otherwise, if the data are regional data, then the outcome
counts must be in self$region_data. See \code{lgcp_bayes()} for more details on the model.

The argument \code{approx} specifies whether to use a full LGCP model (\code{approx='none'}) or whether
to use either a nearest neighbour approximation (\code{approx='nngp'})

Model fitting uses one of several stochastic maximum likelihood algorithms, which have three steps:
\enumerate{
\item Sample random effects using MCMC. Using cmdstanr is recommended as it is much faster. The arguments
\code{mcmc_warmup} and \code{mcmc_sampling} specify the warmup and sampling iterations for this step.
\item Fit fixed effect parameters using expectation maximisation.
\item Fit covariance parameters using expectation maximisation. This third step is the slowest. The NNGP approximation
provides some speed improvements. Otherwise this step can be skipped if the covaraince parameters are "known".
The argument \code{algo} specifies the algorithm, the user can select either MCMC maximum likelihood or stochastic approximation
expectation maximisation with or without Ruppert-Polyak averaging. MCMC-ML can be used with or without adaptive MCMC sample sizes
and either a derivative free or quasi-Newton optimiser (depending on the underlying model).
}

\strong{EXTRACTING PREDICTIONS}

Three outputs can be extracted from the model fit, which will be added as columns to \code{grid_data}:

Predicted incidence: If type includes \code{pred} then \code{pred_mean_total} and
\code{pred_mean_total_sd} provide the
predicted mean total incidence and its standard deviation, respectively.
\code{pred_mean_pp} and \code{pred_mean_pp_sd} provide the predicted population
standardised incidence and its standard deviation.

Relative risk: if type includes \code{rr} then the relative risk is reported in
the columns \code{rr} and \code{rr_sd}. The relative risk here is the exponential
of the latent field, which describes the relative difference between
expexted mean and predicted mean incidence.

Incidence risk ratio: if type includes \code{irr} then the incidence rate ratio (IRR)
is reported in the columns \code{irr} and \code{irr_sd}. This is the ratio of the predicted
incidence in the last period (minus \code{t_lag}) to the predicted incidence in the
last period minus \code{irr_lag} (minus \code{t_lag}). For example, if the time period
is in days then setting \code{irr_lag} to 7 and leaving \code{t_lag=0} then the IRR
is the relative change in incidence in the present period compared to a week
prior.
}
\examples{

## ------------------------------------------------
## Method `grid$new`
## ------------------------------------------------

# a simple example with a square and a small number of cells
# this same running example is used for the other functions 
b1 = sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)

# an example with multiple polygons
data("birmingham_crime")
g2 <- grid$new(birmingham_crime,cellsize = 1000)

## ------------------------------------------------
## Method `grid$plot`
## ------------------------------------------------

b1 = sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
g1$plot()

# a plot with covariates - we simulate covariates first
g1$grid_data$cov <- stats::rnorm(nrow(g1$grid_data))
g1$plot("cov")

## ------------------------------------------------
## Method `grid$points_to_grid`
## ------------------------------------------------

b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
# simulate some points
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20)) 
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
g1$points_to_grid(dp, laglength=5)

## ------------------------------------------------
## Method `grid$add_covariates`
## ------------------------------------------------

b1 <-  sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
cov1 <- grid$new(b1,0.8)
cov1$grid_data$cov <- runif(nrow(cov1$grid_data))
g1$add_covariates(cov1$grid_data,
                  zcols="cov",
                  verbose = FALSE)

\donttest{
# mapping population data from some other polygons
data("boundary")
data("birmingham_crime")
g2 <- grid$new(boundary,cellsize=0.008)
msoa <- sf::st_transform(birmingham_crime,crs = 4326)
suppressWarnings(sf::st_crs(msoa) <- sf::st_crs(g2$grid_data)) # ensure crs matches
g2$add_covariates(msoa,
                  zcols="pop",
                  weight_type="area",
                  verbose=FALSE)
g2$plot("pop")
}

## ------------------------------------------------
## Method `grid$get_dow`
## ------------------------------------------------

b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20))
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
g1$points_to_grid(dp, laglength=5)
dow <- g1$get_dow()
g1$add_covariates(dow,zcols = colnames(dow)[3:ncol(dow)])

## ------------------------------------------------
## Method `grid$lgcp_bayes`
## ------------------------------------------------

# the data are just random simulated points 
b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20))
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
cov1 <- grid$new(b1,0.8)
cov1$grid_data$cov <- runif(nrow(cov1$grid_data))
g1$add_covariates(cov1$grid_data,
                  zcols="cov",
                  verbose = FALSE)
g1$points_to_grid(dp, laglength=5)
g1$priors <- list(
  prior_lscale=c(0,0.5),
  prior_var=c(0,0.5),
  prior_linpred_mean=c(0),
  prior_linpred_sd=c(5)
  )
\donttest{
g1$lgcp_bayes(popdens="cov", approx = "hsgp", parallel_chains = 0)
g1$model_fit()
# we can extract predictions
g1$extract_preds("rr")
g1$plot("rr")
g1$hotspots(rr.threshold = 2)

 # this example uses real aggregated data but will take a relatively long time to run
 data("birmingham_crime")
 example_data <- birmingham_crime[,c(1:8,21)]
 example_data$y <- birmingham_crime$t12
 g2 <- grid$new(example_data,cellsize=1000)
 g2$priors <- list(
  prior_lscale=c(0,0.5),
  prior_var=c(0,0.5),
  prior_linpred_mean=c(-3),
  prior_linpred_sd=c(5)
)
g2$lgcp_bayes(popdens="pop", approx = "hsgp", parallel_chains = 0)
g2$model_fit()
g2$extract_preds("rr")
g2$plot("rr")
g2$hotspots(rr.threshold = 2)
}

## ------------------------------------------------
## Method `grid$lgcp_ml`
## ------------------------------------------------

# a simple example with completely random points
b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20))
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
cov1 <- grid$new(b1,0.8)
cov1$grid_data$cov <- runif(nrow(cov1$grid_data))
g1$add_covariates(cov1$grid_data,
                  zcols="cov",
                  verbose = FALSE)
g1$points_to_grid(dp, laglength=5)
\donttest{
g1$lgcp_ml(popdens="cov",iter_warmup = 100, iter_sampling = 50)
g1$model_fit()
g1$extract_preds("rr")
g1$plot("rr")
g1$hotspots(rr.threshold = 2)

# this example uses real aggregated data but will take a relatively long time to run
 data("birmingham_crime")
 example_data <- birmingham_crime[,c(1:8,21)]
 example_data$y <- birmingham_crime$t12
 g2 <- grid$new(example_data,cellsize=1000)
 g2$lgcp_ml(popdens = "pop",iter_warmup = 100, iter_sampling = 50)
 g2$model_fit()
 g2$extract_preds("rr")
 g2$plot("rr")
 g2$hotspots(rr.threshold = 2) 
}


## ------------------------------------------------
## Method `grid$extract_preds`
## ------------------------------------------------

# See examples for lgcp_bayes() and lgcp_ml()

## ------------------------------------------------
## Method `grid$hotspots`
## ------------------------------------------------

\dontrun{
# See examples for lgcp_bayes() and lgcp_ml()
}

## ------------------------------------------------
## Method `grid$aggregate_output`
## ------------------------------------------------

\donttest{
b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20))
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
cov1 <- grid$new(b1,0.8)
cov1$grid_data$cov <- runif(nrow(cov1$grid_data))
g1$add_covariates(cov1$grid_data,
                  zcols="cov",
                  verbose = FALSE)
g1$points_to_grid(dp, laglength=5)
g1$priors <- list(
  prior_lscale=c(0,0.5),
  prior_var=c(0,0.5),
  prior_linpred_mean=c(0),
  prior_linpred_sd=c(5)
  )
res <- g1$lgcp_bayes(popdens="cov", parallel_chains = 1)
g1$extract_preds(res,
                 type=c("pred","rr"),
                 popdens="cov")
new1 <- g1$aggregate_output(cov1$grid_data,
                            zcols="rr")
}

## ------------------------------------------------
## Method `grid$scale_conversion_factor`
## ------------------------------------------------

b1 = sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
g1$scale_conversion_factor()
}
\references{
(1) Solin A, Särkkä S. Hilbert space methods for reduced-rank Gaussian
process regression. Stat Comput. 2020;30:419–46.
doi:10.1007/s11222-019-09886-w.

(2) Riutort-Mayol G, Bürkner P-C, Andersen MR, Solin A, Vehtari A.
Practical Hilbert space approximate Bayesian Gaussian processes for
probabilistic programming. Stat Comput. 2023;33:17.
doi:10.1007/s11222-022-10167-2.
}
\seealso{
\link[rts2]{create_points}

points_to_grid, add_covariates

points_to_grid, add_covariates
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{grid_data}}{sf object specifying the computational grid for the analysis}

\item{\code{region_data}}{sf object specifying an irregular lattice, such as census areas,
within which case counts are aggregated. Only used if polygon data are provided on
class initialisation.}

\item{\code{priors}}{list of prior distributions for the analysis}

\item{\code{bobyqa_control}}{list of control parameters for the BOBYQA algorithm, must contain named
elements any or all of \code{npt}, \code{rhobeg}, \code{rhoend}, \code{covrhobeg}, \code{covrhoend}.
Only has an effect for the HSGP and NNGP approximations. The latter two parameters control the
covariance parameter optimisation, while the former control the linear predictor.}

\item{\code{boundary}}{sf object showing the boundary of the area of interest}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-grid-new}{\code{grid$new()}}
\item \href{#method-grid-print}{\code{grid$print()}}
\item \href{#method-grid-plot}{\code{grid$plot()}}
\item \href{#method-grid-points_to_grid}{\code{grid$points_to_grid()}}
\item \href{#method-grid-add_covariates}{\code{grid$add_covariates()}}
\item \href{#method-grid-get_dow}{\code{grid$get_dow()}}
\item \href{#method-grid-add_time_indicators}{\code{grid$add_time_indicators()}}
\item \href{#method-grid-lgcp_bayes}{\code{grid$lgcp_bayes()}}
\item \href{#method-grid-lgcp_ml}{\code{grid$lgcp_ml()}}
\item \href{#method-grid-extract_preds}{\code{grid$extract_preds()}}
\item \href{#method-grid-hotspots}{\code{grid$hotspots()}}
\item \href{#method-grid-aggregate_output}{\code{grid$aggregate_output()}}
\item \href{#method-grid-scale_conversion_factor}{\code{grid$scale_conversion_factor()}}
\item \href{#method-grid-get_region_data}{\code{grid$get_region_data()}}
\item \href{#method-grid-variogram}{\code{grid$variogram()}}
\item \href{#method-grid-reorder}{\code{grid$reorder()}}
\item \href{#method-grid-data}{\code{grid$data()}}
\item \href{#method-grid-get_random_effects}{\code{grid$get_random_effects()}}
\item \href{#method-grid-model_fit}{\code{grid$model_fit()}}
\item \href{#method-grid-clone}{\code{grid$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-new"></a>}}
\if{latex}{\out{\hypertarget{method-grid-new}{}}}
\subsection{Method \code{new()}}{
Create a new grid object

Produces a regular grid over an area of interest as an sf object, see details for information on initialisation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$new(poly, cellsize, verbose = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{poly}}{An sf object containing either one polygon describing the area of interest or multiple polygons
representing survey or census regions in which the case data counts are aggregated}

\item{\code{cellsize}}{The dimension of the grid cells}

\item{\code{verbose}}{Logical indicating whether to provide feedback to the console.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# a simple example with a square and a small number of cells
# this same running example is used for the other functions 
b1 = sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)

# an example with multiple polygons
data("birmingham_crime")
g2 <- grid$new(birmingham_crime,cellsize = 1000)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-print"></a>}}
\if{latex}{\out{\hypertarget{method-grid-print}{}}}
\subsection{Method \code{print()}}{
Prints this object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$print()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
None. called for effects.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-plot"></a>}}
\if{latex}{\out{\hypertarget{method-grid-plot}{}}}
\subsection{Method \code{plot()}}{
Plots the grid data
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$plot(zcol)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{zcol}}{Vector of strings specifying names of columns of \code{grid_data} to plot}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A plot
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{b1 = sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
g1$plot()

# a plot with covariates - we simulate covariates first
g1$grid_data$cov <- stats::rnorm(nrow(g1$grid_data))
g1$plot("cov")
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-points_to_grid"></a>}}
\if{latex}{\out{\hypertarget{method-grid-points_to_grid}{}}}
\subsection{Method \code{points_to_grid()}}{
Generates case counts of points over the grid

Counts the number of cases in each time period in each grid cell
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$points_to_grid(
  point_data,
  t_win = c("day"),
  laglength = 14,
  date_format = "ymd",
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{point_data}}{sf object describing the point location of cases with a column
\code{t} of the date of the case in YYYY-MM-DD format. See \link[rts2]{create_points}}

\item{\code{t_win}}{character string. One of "day", "week", or "month" indicating the
length of the time windows in which to count cases}

\item{\code{laglength}}{integer The number of time periods to include counting back from the most
recent time period}

\item{\code{date_format}}{String describing the format of the date in the data as a combination of "d" days, "m" months,
and "y" years, either "dmy", "myd", "ymd", "ydm", "dym" "mdy" as used by the lubridate package.}

\item{\code{verbose}}{Logical indicating whether to report detailed output}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
# simulate some points
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20)) 
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
g1$points_to_grid(dp, laglength=5)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-add_covariates"></a>}}
\if{latex}{\out{\hypertarget{method-grid-add_covariates}{}}}
\subsection{Method \code{add_covariates()}}{
Adds covariate data to the grid

Maps spatial, temporal, or spatio-temporal covariate data onto the grid.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$add_covariates(
  cov_data,
  zcols,
  weight_type = "area",
  popdens = NULL,
  verbose = TRUE,
  t_label = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{cov_data}}{sf, RasterLayer, SpatRaster object or a data.frame. See details.}

\item{\code{zcols}}{vector of character strings with the names of the columns of \code{cov_data}
to include}

\item{\code{weight_type}}{character string. Either "area" for area-weighted average or "pop"
for population-weighted average}

\item{\code{popdens}}{character string. The name of the column in \code{cov_data} with the
population density. Required if weight_type="pop"}

\item{\code{verbose}}{logical. Whether to provide a progress bar}

\item{\code{t_label}}{integer. If adding spatio-temporally varying data by time period,
this time label should be appended to the column name. See details.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{b1 <-  sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
cov1 <- grid$new(b1,0.8)
cov1$grid_data$cov <- runif(nrow(cov1$grid_data))
g1$add_covariates(cov1$grid_data,
                  zcols="cov",
                  verbose = FALSE)

\donttest{
# mapping population data from some other polygons
data("boundary")
data("birmingham_crime")
g2 <- grid$new(boundary,cellsize=0.008)
msoa <- sf::st_transform(birmingham_crime,crs = 4326)
suppressWarnings(sf::st_crs(msoa) <- sf::st_crs(g2$grid_data)) # ensure crs matches
g2$add_covariates(msoa,
                  zcols="pop",
                  weight_type="area",
                  verbose=FALSE)
g2$plot("pop")
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-get_dow"></a>}}
\if{latex}{\out{\hypertarget{method-grid-get_dow}{}}}
\subsection{Method \code{get_dow()}}{
Generate day of week data

Create data frame with day of week indicators

Generates a data frame with indicator
variables for each day of the week for use in the \code{add_covariates()} function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$get_dow()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
data.frame with columns \code{t}, \code{day}, and \code{dayMon} to \code{daySun}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20))
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
g1$points_to_grid(dp, laglength=5)
dow <- g1$get_dow()
g1$add_covariates(dow,zcols = colnames(dow)[3:ncol(dow)])
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-add_time_indicators"></a>}}
\if{latex}{\out{\hypertarget{method-grid-add_time_indicators}{}}}
\subsection{Method \code{add_time_indicators()}}{
Adds time period indicators to the data

Adds indicator variables for each time period to the data. To include
these in a model fitting procedure use, for example, \verb{covs = c("time1i, time2i,...)}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$add_time_indicators()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Nothing. Called for effects.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-lgcp_bayes"></a>}}
\if{latex}{\out{\hypertarget{method-grid-lgcp_bayes}{}}}
\subsection{Method \code{lgcp_bayes()}}{
Fit an (approximate) log-Gaussian Cox Process model using Bayesian methods
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$lgcp_bayes(
  popdens = NULL,
  covs = NULL,
  covs_grid = NULL,
  approx = "nngp",
  m = 10,
  L = 1.5,
  model = "exp",
  known_theta = NULL,
  iter_warmup = 500,
  iter_sampling = 500,
  chains = 3,
  parallel_chains = 3,
  verbose = TRUE,
  vb = FALSE,
  use_cmdstanr = FALSE,
  return_stan_fit = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{popdens}}{character string. Name of the population density column}

\item{\code{covs}}{vector of character string. Base names of the covariates to
include. For temporally-varying covariates only the stem is required and not
the individual column names for each time period (e.g. \code{dayMon} and not \code{dayMon1},
\code{dayMon2}, etc.)}

\item{\code{covs_grid}}{If using a region model, covariates at the level of the grid can also be specified by providing their
names to this argument.}

\item{\code{approx}}{Either "rank" for reduced rank approximation, or "nngp" for nearest
neighbour Gaussian process.}

\item{\code{m}}{integer. Number of basis functions for reduced rank approximation, or
number of nearest neighbours for nearest neighbour Gaussian process. See Details.}

\item{\code{L}}{integer. For reduced rank approximation, boundary condition as proportionate extension of area, e.g.
\code{L=2} is a doubling of the analysis area. See Details.}

\item{\code{model}}{Either "exp" for exponential covariance function or "sqexp" for squared exponential
covariance function}

\item{\code{known_theta}}{An optional vector of two values of the covariance parameters. If these are provided
then the covariance parameters are assumed to be known and will not be estimated.}

\item{\code{iter_warmup}}{integer. Number of warmup iterations}

\item{\code{iter_sampling}}{integer. Number of sampling iterations}

\item{\code{chains}}{integer. Number of chains}

\item{\code{parallel_chains}}{integer. Number of parallel chains}

\item{\code{verbose}}{logical. Provide feedback on progress}

\item{\code{vb}}{Logical indicating whether to use variational Bayes (TRUE) or full MCMC sampling (FALSE)}

\item{\code{use_cmdstanr}}{logical. Defaults to false. If true then cmdstanr will be used
instead of rstan.}

\item{\code{return_stan_fit}}{logical. The results of the model fit are stored internally as an \code{rstFit} object and
returned in that format. If this argument is set to TRUE, then the fitted stan object will instead be returned,
but the \code{rtsFit} object will still be saved.}

\item{\code{...}}{additional options to pass to `$sample()``.}

\item{\code{priors}}{list. See Details}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \link[rstan]{stanfit} or a \code{CmdStanMCMC} object
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# the data are just random simulated points 
b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20))
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
cov1 <- grid$new(b1,0.8)
cov1$grid_data$cov <- runif(nrow(cov1$grid_data))
g1$add_covariates(cov1$grid_data,
                  zcols="cov",
                  verbose = FALSE)
g1$points_to_grid(dp, laglength=5)
g1$priors <- list(
  prior_lscale=c(0,0.5),
  prior_var=c(0,0.5),
  prior_linpred_mean=c(0),
  prior_linpred_sd=c(5)
  )
\donttest{
g1$lgcp_bayes(popdens="cov", approx = "hsgp", parallel_chains = 0)
g1$model_fit()
# we can extract predictions
g1$extract_preds("rr")
g1$plot("rr")
g1$hotspots(rr.threshold = 2)

 # this example uses real aggregated data but will take a relatively long time to run
 data("birmingham_crime")
 example_data <- birmingham_crime[,c(1:8,21)]
 example_data$y <- birmingham_crime$t12
 g2 <- grid$new(example_data,cellsize=1000)
 g2$priors <- list(
  prior_lscale=c(0,0.5),
  prior_var=c(0,0.5),
  prior_linpred_mean=c(-3),
  prior_linpred_sd=c(5)
)
g2$lgcp_bayes(popdens="pop", approx = "hsgp", parallel_chains = 0)
g2$model_fit()
g2$extract_preds("rr")
g2$plot("rr")
g2$hotspots(rr.threshold = 2)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-lgcp_ml"></a>}}
\if{latex}{\out{\hypertarget{method-grid-lgcp_ml}{}}}
\subsection{Method \code{lgcp_ml()}}{
Fit an (approximate) log-Gaussian Cox Process model using Maximum Likelihood
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$lgcp_ml(
  popdens = NULL,
  covs = NULL,
  covs_grid = NULL,
  approx = "nngp",
  m = 10,
  L = 1.5,
  model = "exp",
  known_theta = NULL,
  starting_values = NULL,
  lower_bound = NULL,
  upper_bound = NULL,
  formula_1 = NULL,
  formula_2 = NULL,
  algo = 4,
  alpha = 0.7,
  conv_criterion = 1,
  tol = 0.01,
  max.iter = 30,
  iter_warmup = 100,
  iter_sampling = 250,
  trace = 1,
  use_cmdstanr = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{popdens}}{character string. Name of the population density column}

\item{\code{covs}}{vector of strings. Base names of the covariates to
include. For temporally-varying covariates only the stem is required and not
the individual column names for each time period (e.g. \code{dayMon} and not \code{dayMon1},
\code{dayMon2}, etc.) Alternatively, a formula can be passed to the \code{formula} arguments below.}

\item{\code{covs_grid}}{If using a region model, covariates at the level of the grid can also be specified by providing their
names to this argument. Alternatively, a formula can be passed to the \code{formula} arguments below.}

\item{\code{approx}}{Either "rank" for reduced rank approximation, or "nngp" for nearest
neighbour Gaussian process.}

\item{\code{m}}{integer. Number of basis functions for reduced rank approximation, or
number of nearest neighbours for nearest neighbour Gaussian process. See Details.}

\item{\code{L}}{integer. For reduced rank approximation, boundary condition as proportionate extension of area, e.g.
\code{L=2} is a doubling of the analysis area. See Details.}

\item{\code{model}}{Either "exp" for exponential covariance function or "sqexp" for squared exponential
covariance function}

\item{\code{known_theta}}{An optional vector of two values of the covariance parameters. If these are provided
then the covariance parameters are assumed to be known and will not be estimated.}

\item{\code{starting_values}}{An optional list providing starting values of the model parameters. The list can have named elements
\code{gamma} for the linear predictor parameters, \code{theta} for the covariance parameters, and \code{ar} for the auto-regressive parameter.
If there are covariates for the grid in a region data model then their parameters are \code{gamma_g}. The list elements must be a
vector of starting values. If this is not provided then the non-intercept linear predictor parameters are initialised randomly
as N(0,0.1), the covariance parameters as Uniform(0,0.5) and the auto-regressive parameter to 0.1.}

\item{\code{lower_bound}}{Optional. Vector of lower bound values for the fixed effect parameters.}

\item{\code{upper_bound}}{Optional. Vector of upper bound values for the fixed effect parameters.}

\item{\code{formula_1}}{Optional. Instead of providing a list of covariates above (to \code{covs}) a formula can be specified here. For a regional model, this
argument specified the regional-level fixed effects model.}

\item{\code{formula_2}}{Optional. Instead of providing a list of covariates above (to \code{covs_grid}) a formula can be specified here. For a regional model, this
argument specified the grid-level fixed effects model.}

\item{\code{algo}}{integer. 1 = MCMC ML with L-BFGS for beta and non-approximate covariance parameters,
2 = MCMC ML with BOBYQA for both, 3 = MCMC ML with L-BFGS for beta, BOBYQA for covariance parameters,
4 = SAEM with BOBYQA for both, 5 = SAEM with RP averaging and BOBYQA for both (default), 6-8 = as 1-3 but
with adaptive MCMC sample size that starts at 20 with a max of \code{iter_sampling}}

\item{\code{alpha}}{Optional. Value for alpha in the SAEM parameter.}

\item{\code{conv_criterion}}{Integer. The convergence criterion for the algorithm. 1 = No improvement in the overall log-likelihood with probability 0.95,
2 = No improvement in the log-likelihood for beta with probability 0.95, 3 = Difference between model parameters is less than \code{tol} between iterations.}

\item{\code{tol}}{Scalar indicating the upper bound for the maximum absolute difference between parameter estimates on sucessive iterations, after which the algorithm
terminates.}

\item{\code{max.iter}}{Integer. The maximum number of iterations for the algorithm.}

\item{\code{iter_warmup}}{integer. Number of warmup iterations}

\item{\code{iter_sampling}}{integer. Number of sampling iterations}

\item{\code{trace}}{Integer. Level of detail of information printed to the console. 0 = none, 1 = some (default), 2 = most.}

\item{\code{use_cmdstanr}}{logical. Defaults to false. If true then cmdstanr will be used
instead of rstan.}

\item{\code{...}}{additional options to pass to \verb{$sample()}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Optionally, an \code{rtsFit} model fit object. This fit is stored internally and can be retrieved with \code{model_fit()}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# a simple example with completely random points
b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20))
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
cov1 <- grid$new(b1,0.8)
cov1$grid_data$cov <- runif(nrow(cov1$grid_data))
g1$add_covariates(cov1$grid_data,
                  zcols="cov",
                  verbose = FALSE)
g1$points_to_grid(dp, laglength=5)
\donttest{
g1$lgcp_ml(popdens="cov",iter_warmup = 100, iter_sampling = 50)
g1$model_fit()
g1$extract_preds("rr")
g1$plot("rr")
g1$hotspots(rr.threshold = 2)

# this example uses real aggregated data but will take a relatively long time to run
 data("birmingham_crime")
 example_data <- birmingham_crime[,c(1:8,21)]
 example_data$y <- birmingham_crime$t12
 g2 <- grid$new(example_data,cellsize=1000)
 g2$lgcp_ml(popdens = "pop",iter_warmup = 100, iter_sampling = 50)
 g2$model_fit()
 g2$extract_preds("rr")
 g2$plot("rr")
 g2$hotspots(rr.threshold = 2) 
}

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-extract_preds"></a>}}
\if{latex}{\out{\hypertarget{method-grid-extract_preds}{}}}
\subsection{Method \code{extract_preds()}}{
Extract predictions

Extract incidence and relative risk predictions. The predictions will be extracted from the last model fit. If no previous model fit then use either \code{lgcp_ml()} or \code{lgcp_bayes()}, or see
\code{model_fit()} to update the stored model fit.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$extract_preds(
  type = c("pred", "rr", "irr"),
  irr.lag = NULL,
  t.lag = 0,
  popdens = NULL,
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{Vector of character strings. Any combination of "pred", "rr", and "irr", which are,
posterior mean incidence (overall and population standardised), relative risk,
and incidence rate ratio, respectively.}

\item{\code{irr.lag}}{integer. If "irr" is requested as \code{type} then the number of time
periods lag previous the ratio is in comparison to}

\item{\code{t.lag}}{integer. Extract predictions for previous time periods.}

\item{\code{popdens}}{character string. Name of the column in \code{grid_data} with the
population density data}

\item{\code{verbose}}{Logical indicating whether to print messages to the console}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# See examples for lgcp_bayes() and lgcp_ml()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-hotspots"></a>}}
\if{latex}{\out{\hypertarget{method-grid-hotspots}{}}}
\subsection{Method \code{hotspots()}}{
Generate hotspot probabilities

Generate hotspot probabilities. The last model fit will be used to extract
predictions. If no previous model fit then use either \code{lgcp_ml()} or \code{lgcp_bayes()}, or see
\code{model_fit()} to update the stored model fit.

Given a definition of a hotspot in terms of threshold(s) for incidence,
relative risk, and/or incidence rate ratio, returns the probabilities
each area is a "hotspot". See Details of \code{extract_preds}. Columns
will be added to \code{grid_data}. Note that for incidence threshold, the threshold should
be specified as the per individual incidence.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$hotspots(
  incidence.threshold = NULL,
  irr.threshold = NULL,
  irr.lag = 1,
  rr.threshold = NULL,
  t.lag = 0,
  popdens,
  col_label = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{incidence.threshold}}{Numeric. Threshold of population standardised incidence
above which an area is a hotspot}

\item{\code{irr.threshold}}{Numeric. Threshold of incidence rate ratio
above which an area is a hotspot.}

\item{\code{irr.lag}}{integer. Lag of time period to calculate the incidence rate ratio.
Only required if \code{irr.threshold} is not \code{NULL}.}

\item{\code{rr.threshold}}{numeric. Threshold of local relative risk
above which an area is a hotspot}

\item{\code{t.lag}}{integer. Extract predictions for incidence or relative risk for previous time periods.}

\item{\code{popdens}}{character string. Name of variable in \code{grid_data}
specifying the population density. Needed if \code{incidence.threshold} is not
\code{NULL}}

\item{\code{col_label}}{character string. If not NULL then the name of the column
for the hotspot probabilities.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
None, called for effects. Columns are added to grid or region data.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
# See examples for lgcp_bayes() and lgcp_ml()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-aggregate_output"></a>}}
\if{latex}{\out{\hypertarget{method-grid-aggregate_output}{}}}
\subsection{Method \code{aggregate_output()}}{
Aggregate output

Aggregate \code{lgcp_fit} output to another geography
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$aggregate_output(
  new_geom,
  zcols,
  weight_type = "area",
  popdens = NULL,
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_geom}}{sf object. A set of polygons covering the same area as \code{boundary}}

\item{\code{zcols}}{vector of character strings. Names of the variables in \code{grid_data} to
map to the new geography}

\item{\code{weight_type}}{character string, either "area" or "pop" for area-weighted
or population weighted averaging, respectively}

\item{\code{popdens}}{character string. If \code{weight_type} is equal to "pop" then the
name of the column in \code{grid_data} with population density data}

\item{\code{verbose}}{logical. Whether to provide progress bar.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \code{sf} object identical to \code{new_geom} with additional columns with the
variables specified in \code{zcols}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\donttest{
b1 <- sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
dp <- data.frame(y=runif(10,0,3),x=runif(10,0,3),date=paste0("2021-01-",11:20))
dp <- create_points(dp,pos_vars = c('y','x'),t_var='date')
cov1 <- grid$new(b1,0.8)
cov1$grid_data$cov <- runif(nrow(cov1$grid_data))
g1$add_covariates(cov1$grid_data,
                  zcols="cov",
                  verbose = FALSE)
g1$points_to_grid(dp, laglength=5)
g1$priors <- list(
  prior_lscale=c(0,0.5),
  prior_var=c(0,0.5),
  prior_linpred_mean=c(0),
  prior_linpred_sd=c(5)
  )
res <- g1$lgcp_bayes(popdens="cov", parallel_chains = 1)
g1$extract_preds(res,
                 type=c("pred","rr"),
                 popdens="cov")
new1 <- g1$aggregate_output(cov1$grid_data,
                            zcols="rr")
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-scale_conversion_factor"></a>}}
\if{latex}{\out{\hypertarget{method-grid-scale_conversion_factor}{}}}
\subsection{Method \code{scale_conversion_factor()}}{
Returns scale conversion factor

Coordinates are scaled to \verb{[-1,1]} for LGCP models fit with HSGP. This function
returns the scaling factor for this conversion.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$scale_conversion_factor()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
numeric
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{b1 = sf::st_sf(sf::st_sfc(sf::st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0))))))
g1 <- grid$new(b1,0.5)
g1$scale_conversion_factor()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-get_region_data"></a>}}
\if{latex}{\out{\hypertarget{method-grid-get_region_data}{}}}
\subsection{Method \code{get_region_data()}}{
Returns summary data of the region/grid intersections

Information on the intersection between the region areas and the computational grid
including the number of cells intersecting each region (\code{n_cell}), the indexes of the
cells intersecting each region in order (\code{cell_id}), and the proportion of each region's
area covered by each intersecting grid cell (\code{q_weights}).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$get_region_data()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A named list
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-variogram"></a>}}
\if{latex}{\out{\hypertarget{method-grid-variogram}{}}}
\subsection{Method \code{variogram()}}{
Plots the empirical semi-variogram
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$variogram(popdens, yvar, nbins = 20)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{popdens}}{String naming the variable in the data specifying the offset. If not
provided then no offset is used.}

\item{\code{yvar}}{String naming the outcome variable to calculate the variogram for. Optional, if
not provided then the outcome count data will be used.}

\item{\code{nbins}}{The number of bins in the empirical semivariogram}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A ggplot plot is printed and optionally returned
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-reorder"></a>}}
\if{latex}{\out{\hypertarget{method-grid-reorder}{}}}
\subsection{Method \code{reorder()}}{
Re-orders the computational grid

The quality of the nearest neighbour approximation can depend on the ordering of
the grid cells. This function reorders the grid cells. If this is a region data model,
then the intersections are recomputed.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$reorder(option = "y", verbose = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{option}}{Either "y" for order of the y coordinate, "x" for order of the x coordinate,
"minimax"  in which the next observation in the order is the one which maximises the
minimum distance to the previous observations, or "random" which randomly orders them.}

\item{\code{verbose}}{Logical indicating whether to print a progress bar (TRUE) or not (FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
No return, used for effects.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-data"></a>}}
\if{latex}{\out{\hypertarget{method-grid-data}{}}}
\subsection{Method \code{data()}}{
A list of prepared data

The class prepares data for use in the in-built estimation functions. The same data could be used
for alternative models. This is a utility function to facilitate model fitting for custom models.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$data(m, approx, popdens, covs, covs_grid)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of nearest neighbours or basis functions.}

\item{\code{approx}}{Either "rank" for reduced rank approximation, or "nngp" for nearest
neighbour Gaussian process.}

\item{\code{popdens}}{String naming the variable in the data specifying the offset. If not
provided then no offset is used.}

\item{\code{covs}}{An optional vector of covariate names. For regional data models, this is specifically for the region-level covariates.}

\item{\code{covs_grid}}{An optional vector of covariate names for region data models, identifying the covariates at the grid level.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A named list of data items used in model fitting
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-get_random_effects"></a>}}
\if{latex}{\out{\hypertarget{method-grid-get_random_effects}{}}}
\subsection{Method \code{get_random_effects()}}{
Returns the random effects stored in the object (if any) after using ML fitting. It's main use is
if a fitting procedure is stopped, the random effects can still be returned.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$get_random_effects()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A matrix of random effects samples if a MCMCML model has been initialised, otherwise returns FALSE
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-model_fit"></a>}}
\if{latex}{\out{\hypertarget{method-grid-model_fit}{}}}
\subsection{Method \code{model_fit()}}{
Either returns the stored last model fit with either \code{lgcp_ml} or \code{lgcp_bayes}, or updates
the saved model fit if an object is provided.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$model_fit(fit = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fit}}{Optional. A previous \code{rtsFit} object. If provided then the function updates the internally stored model fit.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Either a \code{rtsFit} object or nothing if no model has been previously fit, or if the fit is updated.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-grid-clone"></a>}}
\if{latex}{\out{\hypertarget{method-grid-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{grid$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
